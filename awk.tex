\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}

\usepackage{xcolor}
\usepackage[most]{tcolorbox}
\usepackage[margin=64pt]{geometry}
\usepackage{varwidth}

\setlength\parindent{0pt}
\setlength{\parskip}{12pt}
\pagenumbering{gobble}
\definecolor{lavender}{rgb}{.8,.4,.9}



\begin{document}

% title
\title{AWK Mini-Primer}
\author{Mark~J.~Duvall\\
\texttt{mjduvall@hawaii.edu}\\
%\textit{University of Hawai'i at M\={a}noa, Department of Physics \& Astronomy}}
%University of Hawai'i at M\={a}noa, Department of Physics \& Astronomy}
UH M\={a}noa Department of Physics \& Astronomy}
\date{}
\maketitle


%% main


\emph{This is a modification of an email I wrote for a colleague. I like AWK, but many people -- even other physicists -- seem unfamiliar with it, so I figured I'd write this up in case anyone finds it useful. Welcome to AWK!}


% intro
\section*{Introduction}


AWK is a simple but very fast and powerful language for processing text files. If you're familiar with grep, it's a lot like that, but a whole language! I've found it especially useful for text-formatted data and for code. Many of its functions are available in modern graphical applications; but these are often slow, resource-intensive, expensive, and worst of all, platform-specific. In contrast, AWK and text-based files are fast, lightweight, free / open-source, and best of all, \emph{extremely portable}.

\textbf{AWK's basic function is to test each line in the input file against a provided pattern and execute specified commands whenever a match is found.}

AWK sees files as ``records,'' containing ``fields.'' By default, each line of the input file is considered a record, and fields are separated by spaces / tabs within that record. (These default delimiters can be changed if needed). AWK uses ``\$'' to indicate a field number; \$1 is the first field, \$2 is the second field, etc.; and \$0 means all fields -- i.e., the entire line. For matching, AWK uses ``$\sim$'' to mean ``matches to.'' The pattern is often provided as a regular expression. In my experience, having a basic knowledge of regular expressions can increase AWK's power \& usefulness tremendously; but more on that later.

Basic Syntax: \,\, \ttfamily awk '[matching test] \{$<$commands$>$\}' $<$filename$>$ \normalfont

Matching tests usually look something like: \$0 $\sim$ /pattern/, which would check each line for any matches to your /pattern/.

The \texttt{\{commands\}} section is often something as simple as:    \texttt{\{print \$1\}}, which would print the first field.

To see how all of this comes together in actual usage, see the example below.


\pagebreak


% basic example
\section*{Basic Example}

Suppose our input file is a list of people's heights called ``heights.txt'' and looks like this:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
Alice 188cm\\
Bill 177cm\\
Clarice 175cm
\end{tabular} }}
\normalfont

It has 3 records, each having 2 fields. Suppose we want to find and print Alice's height; this means we want the first field to match her name. We want to tell AWK, ``If the first field matches 'Alice,' then print the second field.'' That code would look like this:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  awk '\textcolor{red}{\$1} $\sim$ \textcolor{lavender}{/Alice/} \{\textcolor{yellow}{print} \textcolor{red}{\$2}\}' heights.txt\\
188cm\\
%user@host:$\sim$\$\\
\end{tabular} }}
\normalfont

Okay, so Alice is evidently 188 cm tall. Or, we could print the whole line by changing ``print \$2'' to ``print \$0,'' just to make sure we got the right information:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  awk '\textcolor{red}{\$1} $\sim$ \textcolor{lavender}{/Alice/} \{{\textcolor{yellow}{print} \textcolor{red}{\$0}}\}' heights.txt\\
Alice 188cm\\
%user@host:$\sim$\$\\
\end{tabular} }}
\normalfont

So it worked! In case you're wondering, we've enclosed ``Alice'' in slashes (in this particular case, double quotes would also have been fine) to indicate that it's supposed to be taken as a whole and not just a series of characters. Without doing this, AWK would read 'Alice' as 'A \textit{or} l \textit{or} i \textit{or} c \textit{or} e,' and since all 3 names happen to contain an ``i,'' we'd end up printing everyone's heights:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  awk '\textcolor{red}{\$1} $\sim$ \textcolor{lavender}{Alice} \{\textcolor{yellow}{print} \textcolor{red}{\$2}\}' heights.txt\\
188cm\\
177cm\\
175cm
%user@host:$\sim$\$\\
\end{tabular} }}
\normalfont

This is obviously not what we wanted; that's why we need to use /Alice/ or ``Alice''. A tiny example of regular expressions (``regexes''): If we wanted to find Bill's height but there was also a ``Billy'' on the list, we'd be in trouble, since ``Billy'' contains a match for the pattern ``Bill''. We'd avoid this by using the regex special characters ``$\wedge$'' for ``beginning of string'' and ``\$'' for ``end of string'': the pattern /$\wedge$Bill\$/ would match only ``Bill'' and not ``Billy''.


That's it! Those are the bare-bones basics of how AWK works. Once you get a bit used to it, you'll likely find yourself using it quite regularly if you work with text files a lot. Furthermore, this only scratches the surface of what this language can do; for a \emph{slightly} deeper demonstration of AWK's power, see the more advanced examples below. Happy AWKing!



\# \# \# \# \#



\pagebreak

\section*{Intermediate Example}

Suppose we received a message from Clarice that there's been a mistake somewhere (not our fault, of course), and her height in our database is incorrect. Specifically, let's say her height is actually 185~cm, not 175~cm as listed in our file.
No worries! One of AWK's most powerful features is the ability to reassign new values to fields.
In this case, we'll correct the file usign the following steps:
\begin{enumerate}
  \item For any record(s) \emph{not} matching ``Clarice'', print the whole record without modification.
  \item For any record(s) matching ``Clarice,'' replace the second field with the correct value, then print the corrected record.
\end{enumerate}

We can accomplish this by giving AWK two sets of matching tests: one for ``does not match \emph{Clarice},'' and one for ``matches \emph{Clarice}.'' To be more efficient, we'll only test the ``name'' field for matches rather than the whole record:

\begin{enumerate}
  \item We use the ``!'' character to negate the match for \emph{Clarice}:\\
  \texttt{\$1 !$\sim$ /Clarice/ \{print \$0\}}\\
  This means, ``For any record (i.e., line) whose name does not contain a match for `Clarice,' print the whole line.''
  \item We use ``\$2=185cm'' to reassign the height field:\\
  \texttt{\$1 $\sim$ /Clarice/ \{\$2 = ``185cm''; print \$0\}}\\
  This means, ``Find a record whose name field matches `Clarice,' then replace the height field with her corrected height and print the new record.''\\
\end{enumerate}

This would all be done at once, writing the output to a new file \texttt{heights\_corrected.txt}, as follows:

\ttfamily
\colorbox{black}{\textcolor{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$ } cat heights.txt | awk '\textcolor{red}{\$1} !$\sim$ \textcolor{lavender}{/Clarice/} \{\textcolor{yellow}{print} \textcolor{red}{\$0}\}; \textbackslash \\
  \textcolor{gray}{$>$} \textcolor{red}{\$1} $\sim$ \textcolor{lavender}{/Clarice/} \{\textcolor{red}{\$2=``185cm''}; \textcolor{yellow}{print \$0}\} $>$ heigts\_corrected.txt'
\end{tabular} }}
\normalfont




%\pagebreak


\section*{Advanced Example}

A somewhat more advanced example of AWK usage would be to strip the ``cm'' from each line, perhaps to prepare heights.txt for importing into a spreadsheet or data analysis program.
(However, it should be noted that this is still just the tip of the iceberg regarding AWK's capabilities).
In this case, we'll want to write AWK's output to a new file, which we'll do via the usual shell output redirection ``$>$ \emph{newfilename}'' at the end of the command line.
And while we're at it, let's make the file a little easier to read by putting a couple of tabs between the fields rather than just a space.
I won't cover these details here, but just as a demonstration of AWK's power, it would look like this:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  awk '\{\textcolor{cyan}{match}(\textcolor{red}{\$2}, \textcolor{lavender}{/[}\textcolor{yellow}{[:digit:]}\textcolor{lavender}{]}\textcolor{red}{$\ast$}\textcolor{lavender}{/}, a); \textcolor{yellow}{print} \textcolor{red}{\$1}``\textcolor{red}{\textbackslash t\textbackslash t}''a[0]\}' \textbackslash \\
\textcolor{gray}{$>$} heights.txt $>$ heights\_without\_units.txt
\end{tabular}
}}
\normalfont

Now let's compare the original file with the new version:

\ttfamily
\colorbox{black}{\color{white}{
\textcolor{gray}{user@host:$\sim$\$} cat heights.txt; echo; cat heights\_without\_units.txt}}

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
Alice 188cm\\
Bill 177cm\\
Clarice 175cm
\end{tabular} }}

\colorbox{black}{\color{white}{
\begin{tabular}{l l l}
Alice	& & 	188\\
Bill	& & 	177\\
Clarice	& & 	175
%user@host:$\sim$\$
\end{tabular} }}
\normalfont

There, that's much nicer. And since the heights in the new file are now pure numbers rather than character strings, we can operate on them as well! For example, we could print the names of all people shorter than 180 cm:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  awk '\textcolor{red}{\$2} $<$ \textcolor{lavender}{180} \{\textcolor{yellow}{print} \textcolor{red}{\$1}\}' heights\_without\_units.txt\\
Bill\\
Clarice\\
%user@host:$\sim$\$
\end{tabular} }}
\normalfont

Just for fun, let's see what that entire process might look like in a single line using pipes. So, in a single line, we'll take the original input file, strip the ``cm,'' then use the results to print the names of all people shorter than 180 cm:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  cat heights.txt | awk '\{\textcolor{cyan}{match}(\textcolor{red}{\$2}, \textcolor{lavender}{/[}\textcolor{yellow}{[:digit:]}\textcolor{lavender}{]}\textcolor{red}{$\ast$}\textcolor{lavender}{/}, a); \textbackslash \\
\textcolor{gray}{$>$} \textcolor{yellow}{print} \textcolor{red}{\$1}``\textcolor{red}{\textbackslash t\textbackslash t}''a[0]\}' | awk '\textcolor{red}{\$2} $<$ \textcolor{lavender}{180} \{\textcolor{yellow}{print} \textcolor{red}{\$1}\}'\\
Bill\\
Clarice
%user@host:$\sim$\$
\end{tabular} }}
\normalfont

Done! In a real-world scenario where we might have hundreds of names instead of just three, AWK has just made our lives \emph{much, much easier}.

%\pagebreak

\section*{AWK Scripting}

Finally, I'll note that you don't always have to enter all of your AWK code on the command line. In fact, as your AWK programs get more complex, you definitely won't want to do that! Fortunately, the AWK language can use scripts like most other languages. Just save your AWK code in a text file ('.awk' extension is common for convenience but not necessary), and use the '-f' option when you call AWK from the command line:\\
\texttt{awk -f $<$codefile$>$ $<$targetfile$>$}

This also has the added benefit of syntax highlighting in compatible text editors. (\emph{vim FTW!})

For example, we could create a file called stripcm.awk that looks like this:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{cyan}{\# stripcm.awk -- script to remove the ``cm'' from people's heights}\\
\textcolor{yellow}{match}(\textcolor{red}{\$2}, \textcolor{lavender}{/[}\textcolor{yellow}{[:digit:]}\textcolor{lavender}{]}\textcolor{red}{$\ast$}\textcolor{lavender}{/}, a)\\
\textcolor{yellow}{print} \textcolor{red}{\$1}``\textcolor{red}{\textbackslash t\textbackslash t}''a[0]\\
\end{tabular} }}
\normalfont

Then we would run it as follows:

\ttfamily
\colorbox{black}{\color{white}{
\textcolor{gray}{user@host:$\sim$\$}  awk -f stripcm.awk heights.txt}}

\colorbox{black}{\color{white}{
\begin{tabular}{l l l}
Alice	& &	188\\
Bill	& &	177\\
Clarice	& &	175
%user@host:$\sim$\$
\end{tabular} }}
\normalfont

Units stripped \& columns aligned!

Our entire process to 1) strip the ``cm'' and therefore turn the heights from strings into numbers and 2) examine these numbers and print out the heights of everyone under 180~cm could now look like:

\ttfamily
\colorbox{black}{\color{white}{
\begin{tabular}{l}
\textcolor{gray}{user@host:$\sim$\$}  cat heights.txt | awk -f stripcm.awk | awk '\textcolor{red}{\$2} < \textcolor{lavender}{180} \textcolor{yellow}{{print} \textcolor{red}{\$1}}'\\
Bill\\
Clarice
%user@host:$\sim$\$
\end{tabular} }}
\normalfont

That cleans things up quite a bit. And just like that, we're pau!


\# \# \# \# \#



There's a whole lot more to AWK than this, but that's all for now. Enjoy!


\emph{Mark~J.~Duvall $\sim$ mjduvall@hawaii.edu}



% all pau!
\end{document}
